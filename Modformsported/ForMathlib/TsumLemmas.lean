import Mathlib.Data.Complex.Exponential
import Mathlib.Analysis.Calculus.Series
import Mathlib.Analysis.Calculus.ParametricIntervalIntegral
import Mathlib.Data.Complex.Basic

noncomputable section

open TopologicalSpace Set Metric Filter Function Complex MeasureTheory

open scoped Interval Real NNReal ENNReal Topology BigOperators Nat Classical

section coe_lems

theorem embedding_coer : Embedding (Complex.ofReal' : ‚Ñù ‚Üí ‚ÑÇ) :=
  by
  apply Isometry.embedding
  have := isometry_ofReal
  convert this


@[norm_cast]
theorem tendsto_coe {Œ± : Type _} {f : Filter Œ±} {m : Œ± ‚Üí ‚Ñù} {a : ‚Ñù} :
    Tendsto (fun a => (m a : ‚ÑÇ)) f (ùìù ‚Üëa) ‚Üî Tendsto m f (ùìù a) :=
  embedding_coer.tendsto_nhds_iff.symm

@[simp, norm_cast]
theorem coe_finset_sum' {Œ± : Type _} {s : Finset Œ±} {f : Œ± ‚Üí ‚Ñù} :
    ‚Üë(‚àë a in s, f a) = (‚àë a in s, f a : ‚ÑÇ) :=
  ofReal.map_sum f s

@[norm_cast]
theorem hasSum_coe {Œ± : Type _} {f : Œ± ‚Üí ‚Ñù} {r : ‚Ñù} :
    HasSum (fun a => (f a : ‚ÑÇ)) ‚Üër ‚Üî HasSum f r :=
  by
  have :
    (fun s : Finset Œ± => ‚àë a in s, ‚Üë(f a)) =
      (Complex.ofReal' : ‚Ñù ‚Üí ‚ÑÇ) ‚àò fun s : Finset Œ± => ‚àë a in s, f a :=
    funext fun s => coe_finset_sum'.symm
  unfold HasSum
  rw [this]
  apply tendsto_coe

theorem tsum_coe_eq {Œ± : Type _} {f : Œ± ‚Üí ‚Ñù} {r : ‚Ñù} (h : HasSum f r) :
    ‚àë' a, (f a : ‚ÑÇ) = r :=
  (hasSum_coe.2 h).tsum_eq

theorem coe_tsum {Œ± : Type _} {f : Œ± ‚Üí ‚Ñù} : Summable f ‚Üí ‚Üë(tsum f) = ‚àë' a, (f a : ‚ÑÇ)
  | ‚ü®r, hr‚ü© => by rw [hr.tsum_eq, tsum_coe_eq hr]

theorem coe_summable {Œ± : Type _} (f : Œ± ‚Üí ‚Ñù) :
  Summable ((Complex.ofReal' : ‚Ñù ‚Üí ‚ÑÇ) ‚àò f) ‚Üî Summable f :=
  by
  apply Summable.map_iff_of_leftInverse Complex.ofReal Complex.reAddGroupHom
  exact Complex.continuous_ofReal
  exact Complex.continuous_re
  intro; rfl

theorem tsum_coe {Œ± : Type _} (f : Œ± ‚Üí ‚Ñù) : ‚àë' i, (f i : ‚ÑÇ) = (‚àë' i, f i : ‚Ñù) :=
  by
  by_cases hf : Summable f
  apply (coe_tsum hf).symm
  have := tsum_eq_zero_of_not_summable hf
  rw [this]
  simp
  apply tsum_eq_zero_of_not_summable
  simp at *
  apply hf

section pnat_tsums

theorem nat_pos_tsum2   {Œ± : Type _} [TopologicalSpace Œ±] [AddCommMonoid Œ±]
  (f : ‚Ñï ‚Üí Œ±) (hf : f 0 = 0) : (Summable fun x : ‚Ñï+ => f x) ‚Üî Summable f :=
  by
  apply Function.Injective.summable_iff
  exact PNat.coe_injective
  intro x hx
  simp at *
  by_cases h : 0 < x
  have := hx ‚ü®x,h‚ü©
  simp at this
  simp at *
  rw [h]
  exact hf

variable {Œ± : Type _}

theorem hasSum_pnat' (f : ‚Ñï ‚Üí ‚ÑÇ) (hf2 : Summable f) :
    HasSum (fun n : ‚Ñï => f (n + 1)) (‚àë' n : ‚Ñï+, f n) :=
  by
  rw  [‚Üê _root_.Equiv.pnatEquivNat.hasSum_iff]
  simp_rw [Equiv.pnatEquivNat] at *
  simp at *
  have hf3 : Summable ((fun n : ‚Ñï => f (n + 1)) ‚àò PNat.natPred) :=
    by
    have hs : Summable fun n : ‚Ñï+ => f n := by
      apply hf2.subtype
    apply Summable.congr hs
    intro b; simp
  rw [Summable.hasSum_iff hf3]
  congr
  funext
  simp

theorem nat_pos_tsum2' [TopologicalSpace Œ±] [AddCommMonoid Œ±]  (f : ‚Ñï ‚Üí Œ±) :
    (Summable fun x : ‚Ñï+ => f x) ‚Üî Summable fun x : ‚Ñï => f (x + 1) :=
  by
  rw [‚Üê Equiv.summable_iff _root_.Equiv.pnatEquivNat]
  constructor
  intro hf
  apply Summable.congr hf
  intro b
  simp
  intro hf
  apply Summable.congr hf
  intro b
  simp



theorem tsum_pNat {Œ± : Type _} [AddCommGroup Œ±] [UniformSpace Œ±] [UniformAddGroup Œ±] [T2Space Œ±]
  [CompleteSpace Œ±] (f : ‚Ñï ‚Üí Œ±) (hf : f 0 = 0) : ‚àë' n : ‚Ñï+, f n = ‚àë' n, f n :=
  by
  by_cases hf2 : Summable f
  rw [tsum_eq_zero_add]
  rw [hf]
  simp
  have hpos : HasSum (fun n : ‚Ñï => f (n + 1)) (‚àë' n : ‚Ñï+, f n) :=
    by
    rw  [‚Üê _root_.Equiv.pnatEquivNat.hasSum_iff]
    simp_rw [Equiv.pnatEquivNat] at *
    simp at *
    have hf3 : Summable ((fun n : ‚Ñï => f (n + 1)) ‚àò PNat.natPred) :=
      by
      have hs : Summable fun n : ‚Ñï+ => f n := by
        apply hf2.subtype
      apply Summable.congr hs
      intro b; simp
    rw [Summable.hasSum_iff hf3]
    congr
    funext
    simp
  apply symm
  apply hpos.tsum_eq
  apply hf2
  have h1 := tsum_eq_zero_of_not_summable hf2
  rw [‚Üê nat_pos_tsum2 f hf] at hf2
  have h2 := tsum_eq_zero_of_not_summable hf2
  simp [h1, h2]

theorem tsum_pnat' [TopologicalSpace Œ±] [AddCommMonoid Œ±]  [T2Space Œ±] (f : ‚Ñï ‚Üí Œ±) :
  ‚àë' n : ‚Ñï+, f n = ‚àë' n, f (n + 1) :=
  by
  by_cases hf2 : Summable fun n : ‚Ñï+ => f n
  have hpos : HasSum (fun n : ‚Ñï => f (n + 1)) (‚àë' n : ‚Ñï+, f n) :=
    by
    rw  [‚Üê _root_.Equiv.pnatEquivNat.hasSum_iff]
    simp_rw [Equiv.pnatEquivNat] at *
    simp at *
    have hf3 : Summable ((fun n : ‚Ñï => f (n + 1)) ‚àò PNat.natPred) :=
      by
      apply Summable.congr hf2
      intro b; simp
    rw [Summable.hasSum_iff hf3]
    congr
    funext
    simp
  apply symm
  apply hpos.tsum_eq
  have h1 := tsum_eq_zero_of_not_summable hf2
  rw [nat_pos_tsum2'] at hf2
  have h2 := tsum_eq_zero_of_not_summable hf2
  simp [h1, h2]





section prod_lems


variable {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} {i : Œ± ‚Üí Set Œ≤}

def unionEquiv (Œπ : ‚Ñï ‚Üí Finset (‚Ñ§ √ó ‚Ñ§)) (HI : ‚àÄ y : ‚Ñ§ √ó ‚Ñ§, ‚àÉ! i : ‚Ñï, y ‚àà Œπ i) :
    (‚ãÉ s : ‚Ñï, ((Œπ s) : Set (‚Ñ§ √ó ‚Ñ§))) ‚âÉ ‚Ñ§ √ó ‚Ñ§ where
  toFun x := x.1
  invFun x := by
    use x
    simp
    obtain ‚ü®i, hi1,_‚ü©:= HI x
    refine ‚ü®i,hi1‚ü©
  left_inv := by  intro x; cases x; rfl
  right_inv := by intro x; rfl

theorem summable_disjoint_union_of_nonneg {i : Œ± ‚Üí Set Œ≤} {f : (‚ãÉ x, i x) ‚Üí ‚Ñù}
    (h : ‚àÄ a b, a ‚â† b ‚Üí Disjoint (i a) (i b)) (hf : ‚àÄ x, 0 ‚â§ f x) :
    Summable f ‚Üî
      (‚àÄ x, Summable fun y : i x => f ‚ü®y,  Set.mem_iUnion_of_mem (x) y.2 ‚ü©) ‚àß
        Summable fun x => ‚àë' y : i x, f ‚ü®y, Set.mem_iUnion_of_mem (x) y.2 ‚ü© :=
  by
  let h0 := (Set.unionEqSigmaOfDisjoint h).symm
  have h01 : Summable f ‚Üî Summable (f ‚àò h0) := by
   rw [Equiv.summable_iff]
  have h22 : ‚àÄ y : Œ£ s : Œ±, i s, 0 ‚â§ (f ‚àò h0) y :=
    by
    intro y
    simp
    apply hf
  have h1 := summable_sigma_of_nonneg h22
  rw [‚Üêh01] at h1;
  convert h1

theorem tsum_disjoint_union_of_nonneg' {Œ≥ : Type} [AddCommGroup Œ≥]  [ UniformSpace Œ≥]
    [UniformAddGroup Œ≥] [CompleteSpace Œ≥] [T0Space Œ≥] [T2Space Œ≥]
    {i : Œ± ‚Üí Set Œ≤} {f : (‚ãÉ x, i x) ‚Üí Œ≥}
    (h : ‚àÄ a b, a ‚â† b ‚Üí Disjoint (i a) (i b)) (h1 : Summable f) :
    ‚àë' x, f x = ‚àë' x, ‚àë' y : i x, f ‚ü®y, Set.mem_iUnion_of_mem (x) y.2‚ü© :=
  by
  let h0 := (Set.unionEqSigmaOfDisjoint h).symm
  have h11 : ‚àë' x, f x = ‚àë' y, f (h0 y) := by have := Equiv.tsum_eq h0 f; rw [‚Üê this]
  rw [h11]
  rw [tsum_sigma]
  rfl
  have h01 : Summable f ‚Üî Summable (f ‚àò h0) := by rw [Equiv.summable_iff]
  convert (h01.1 h1)

theorem disjoint_aux (In : ‚Ñï ‚Üí Finset (‚Ñ§ √ó ‚Ñ§)) (HI : ‚àÄ y : ‚Ñ§ √ó ‚Ñ§, ‚àÉ! i : ‚Ñï, y ‚àà In i) :
    ‚àÄ i j : ‚Ñï, i ‚â† j ‚Üí Disjoint (In i) (In j) :=
  by
  intro i j h
  intro x h1 h2 a h3
  cases' a with a_fst a_snd
  dsimp at *
  simp at *
  have HI0 := HI a_fst a_snd
  have := ExistsUnique.unique HI0 (h1 h3) (h2 h3)
  rw [this] at h
  simp at *

theorem sum_lemma (f : ‚Ñ§ √ó ‚Ñ§ ‚Üí ‚Ñù) (h : ‚àÄ y : ‚Ñ§ √ó ‚Ñ§, 0 ‚â§ f y) (Œπ : ‚Ñï ‚Üí Finset (‚Ñ§ √ó ‚Ñ§))
    (HI : ‚àÄ y : ‚Ñ§ √ó ‚Ñ§, ‚àÉ! i : ‚Ñï, y ‚àà Œπ i) : Summable f ‚Üî Summable fun n : ‚Ñï => ‚àë x in Œπ n, f x :=
  by
  let h2 := unionEquiv Œπ HI
  have h22 : ‚àÄ y : ‚ãÉ s : ‚Ñï, (Œπ s), 0 ‚â§ (f ‚àò h2) y :=
    by
    intro y
    apply h
  have hdis' := disjoint_aux Œπ HI
  have hdis : ‚àÄ a b : ‚Ñï, a ‚â† b ‚Üí Disjoint ((Œπ a)) ((Œπ b)) :=
    by
    intro a b hab;
    apply hdis'; exact hab
  have h3 := summable_disjoint_union_of_nonneg ?_ h22
  have h4 : Summable f ‚Üî Summable (f ‚àò h2) := by rw [Equiv.summable_iff]
  rw [h4]
  rw [h3]
  constructor
  intro H
  convert H.2
  rw [‚ÜêFinset.tsum_subtype]
  rfl
  intro H
  constructor
  intro x
  simp
  rw [unionEquiv]
  simp
  apply Finset.summable
  convert H
  rw [‚ÜêFinset.tsum_subtype]
  rfl
  norm_cast

theorem tsum_lemma {Œ≥ : Type} [AddCommGroup Œ≥]  [ UniformSpace Œ≥]
    [UniformAddGroup Œ≥] [CompleteSpace Œ≥] [T0Space Œ≥] [T2Space Œ≥]
    (f : ‚Ñ§ √ó ‚Ñ§ ‚Üí Œ≥) (Œπ : ‚Ñï ‚Üí Finset (‚Ñ§ √ó ‚Ñ§)) (HI : ‚àÄ y : ‚Ñ§ √ó ‚Ñ§, ‚àÉ! i : ‚Ñï, y ‚àà Œπ i)
    (hs : Summable f) : ‚àë' x, f x = ‚àë' n : ‚Ñï, ‚àë x in Œπ n, f x :=
  by
  let h2 := unionEquiv Œπ HI
  have hdis' := disjoint_aux Œπ HI
  have hdis : ‚àÄ a b : ‚Ñï, a ‚â† b ‚Üí Disjoint ( (Œπ a)) ((Œπ b)) :=
    by
    intro a b hab;
    apply hdis'; exact hab
  have HS : Summable (f ‚àò h2) := by rw [Equiv.summable_iff h2]; exact hs
  have HH := tsum_disjoint_union_of_nonneg' ?_ HS
  simp at HH
  have := Equiv.tsum_eq h2 f
  rw [‚Üê this]
  rw [HH]
  rw [unionEquiv]
  simp
  norm_cast





theorem prod_sum
  (f : ‚Ñ§ √ó ‚Ñ§ ‚Üí ‚ÑÇ) (hf : Summable f) : Summable fun a => ‚àë' b, f ‚ü®a, b‚ü© :=
  by
  rw [‚Üê Equiv.summable_iff (Equiv.sigmaEquivProd ‚Ñ§ ‚Ñ§)] at hf
  have H := Summable.sigma hf
  simp at H
  apply Summable.congr H
  intro b
  simp

def mapdiv (n : ‚Ñï+) : Nat.divisorsAntidiagonal n ‚Üí ‚Ñï+ √ó ‚Ñï+ :=
  by
  intro x
  have h11 := Nat.fst_mem_divisors_of_mem_antidiagonal x.2
  have h111 := Nat.pos_of_mem_divisors h11
  have h22 := Nat.snd_mem_divisors_of_mem_antidiagonal x.2
  have h222 := Nat.pos_of_mem_divisors h22
  set n1 : ‚Ñï+ := ‚ü®x.1.1, h111‚ü©
  set n2 : ‚Ñï+ := ‚ü®x.1.2, h222‚ü©
  use n1
  use n2
  exact h222

variable (f : Œ£ n : ‚Ñï+, Nat.divisorsAntidiagonal n)

def sigmaAntidiagonalEquivProd : (Œ£ n : ‚Ñï+, Nat.divisorsAntidiagonal n) ‚âÉ ‚Ñï+ √ó ‚Ñï+
    where
  toFun x := mapdiv x.1 x.2
  invFun x :=
    ‚ü®‚ü®x.1.1 * x.2.1, by apply mul_pos x.1.2 x.2.2‚ü©, ‚ü®x.1, x.2‚ü©, by
      rw [Nat.mem_divisorsAntidiagonal]; simp; constructor; rfl; rw [not_or]; constructor;
        linarith [x.1.2]; linarith [x.2.2] ‚ü©
  left_inv := by
    rintro ‚ü®n, ‚ü®k, l‚ü©, h‚ü©
    rw [Nat.mem_divisorsAntidiagonal] at h
    simp_rw [mapdiv]
    simp only [h, PNat.mk_coe, eq_self_iff_true, Subtype.coe_eta, true_and_iff]
    ext
    simp at *
    simp_rw [h]
    norm_cast
    simp only
    simp only
  right_inv := by
    rintro ‚ü®n, ‚ü®k, l‚ü©, h‚ü©
    simp_rw [mapdiv]
    exfalso

    simp at *
    simp_rw [mapdiv]
    simp [eq_self_iff_true, Subtype.coe_eta]
    norm_cast

theorem summable_mul_prod_iff_summable_mul_sigma_antidiagonall {Œ± : Type _} [TopologicalSpace Œ±]
  [AddCommMonoid Œ±] {f : ‚Ñï+ √ó ‚Ñï+ ‚Üí Œ±} :
    (Summable fun x : ‚Ñï+ √ó ‚Ñï+ => f x) ‚Üî
      Summable fun x : Œ£ n : ‚Ñï+, Nat.divisorsAntidiagonal n =>
        f ‚ü®(mapdiv x.1 x.2).1, (mapdiv x.1 x.2).2‚ü© :=
  by
  simp_rw [mapdiv]
  apply sigmaAntidiagonalEquivProd.summable_iff.symm

/-
theorem nat_pos_tsum' (Œæ : ‚ÑÇ) :
    (Summable fun n : ‚Ñï => Œæ ^ n) ‚Üí Summable fun n : ‚Ñï+ => Œæ ^ (n : ‚Ñï) :=
  by
  intro h
  apply h.subtype
 -/

theorem sumaux [TopologicalSpace Œ±] [AddCommMonoid Œ±]  (f : ‚Ñï √ó ‚Ñï ‚Üí Œ±) (e : ‚Ñï+) :
    ‚àë x : Nat.divisorsAntidiagonal e, f x = ‚àë x : ‚Ñï √ó ‚Ñï in Nat.divisorsAntidiagonal e, f x :=
  by
  simp only [Finset.univ_eq_attach]
  apply Finset.sum_finset_coe

theorem int_nat_sum [AddCommGroup Œ±] [UniformSpace Œ±] [ UniformAddGroup Œ±]  [CompleteSpace Œ±]
  (f : ‚Ñ§ ‚Üí Œ±) : Summable f ‚Üí Summable fun x : ‚Ñï => f x :=
  by
  have : IsCompl (Set.range (Int.ofNat : ‚Ñï ‚Üí ‚Ñ§)) (Set.range Int.negSucc) :=
    by
    constructor
    ¬∑ rw [disjoint_iff_inf_le]
      rintro _ ‚ü®‚ü®i, rfl‚ü©, ‚ü®j, ‚ü®‚ü©‚ü©‚ü©
    ¬∑ rw [codisjoint_iff_le_sup]
      rintro (i | j) _
      exacts [Or.inl ‚ü®_, rfl‚ü©, Or.inr ‚ü®_, rfl‚ü©]
  intro h
  have H:= @summable_subtype_and_compl _ _ _ _ _ f _ (Set.range (Int.ofNat : ‚Ñï ‚Üí ‚Ñ§))
  simp at H
  rw [‚Üê H] at h
  cases' h with h_left h_right
  rw [‚Üê (Equiv.ofInjective (Int.ofNat : ‚Ñï ‚Üí ‚Ñ§) Nat.cast_injective).symm.summable_iff]
  apply Summable.congr h_left
  intro b
  funext
  simp
  apply congr_arg
  exact Eq.symm (Equiv.apply_ofInjective_symm Nat.cast_injective b)

theorem int_pnat_sum [AddCommGroup Œ±] [UniformSpace Œ±] [ UniformAddGroup Œ±]  [CompleteSpace Œ±]
  (f : ‚Ñ§ ‚Üí Œ±) : Summable f ‚Üí Summable fun x : ‚Ñï+ => f x := by
  intro h
  have :=int_nat_sum f h
  apply this.subtype

theorem sum_int_even  [UniformSpace Œ±] [CommRing Œ±]  [ UniformAddGroup Œ±] [CompleteSpace Œ±]
  [T2Space Œ±] (f : ‚Ñ§ ‚Üí Œ±) (hf : ‚àÄ n : ‚Ñ§, f n = f (-n)) (hf2 : Summable f) :
    ‚àë' n, f n = f 0 + 2 * ‚àë' n : ‚Ñï+, f n :=
  by
  have hpos : HasSum (fun n : ‚Ñï => f (n + 1)) (‚àë' n : ‚Ñï+, f n) :=
    by
    rw [‚Üê _root_.Equiv.pnatEquivNat.hasSum_iff]
    simp_rw [Equiv.pnatEquivNat] at *
    simp at *
    have hf3 : Summable ((fun n : ‚Ñï => f (‚Üën + 1)) ‚àò PNat.natPred) :=
      by
      have hs : Summable fun n : ‚Ñï+ => f n := by apply (int_nat_sum f hf2).subtype
      apply Summable.congr hs
      intro b; simp; congr; simp
    rw [Summable.hasSum_iff hf3]
    congr
    funext
    simp
    congr
    norm_cast
    simp
  have hneg : HasSum (fun n : ‚Ñï => f (-n.succ)) (‚àë' n : ‚Ñï+, f n) :=
    by
    have h1 : (fun n : ‚Ñï => f (-‚Üën.succ)) = fun n : ‚Ñï => f ‚Üën.succ :=
      by
      funext
      apply hf
    rw [h1]
    convert hpos
  have := (HasSum.pos_add_zero_add_neg hpos hneg).tsum_eq
  rw [this]
  ring

def negEquiv : ‚Ñ§ ‚âÉ ‚Ñ§ where
  toFun n := -n
  invFun n := -n
  left_inv := by apply neg_neg
  right_inv := by apply neg_neg

def succEquiv : ‚Ñ§ ‚âÉ ‚Ñ§ where
  toFun n := n.succ
  invFun n := n.pred
  left_inv := by apply Int.pred_succ
  right_inv := by apply Int.succ_pred

theorem summable_neg  [TopologicalSpace Œ±] [AddCommMonoid Œ±] (f : ‚Ñ§ ‚Üí Œ±) (hf : Summable f) :
  Summable fun d => f (-d) :=
  by
  have h : (fun d => f (-d)) = (fun d => f d) ‚àò negEquiv.toFun :=
    by
    funext
    simp
    rfl
  rw [h]
  have := negEquiv.summable_iff.mpr hf
  apply this

theorem int_sum_neg [AddCommMonoid Œ±] [TopologicalSpace Œ±] [T2Space Œ±] (f : ‚Ñ§ ‚Üí Œ±) :
  ‚àë' d : ‚Ñ§, f d = ‚àë' d, f (-d) :=
  by
  have h : (fun d => f (-d)) = (fun d => f d) ‚àò negEquiv.toFun :=
    by
    funext
    simp
    rfl
  rw [h]
  apply symm
  apply negEquiv.tsum_eq


theorem int_tsum_pNat [UniformSpace Œ±] [CommRing Œ±]  [ UniformAddGroup Œ±] [CompleteSpace Œ±]
  [T2Space Œ±] (f : ‚Ñ§ ‚Üí Œ±) (hf2 : Summable f) :
  ‚àë' n, f n = f 0 + ‚àë' n : ‚Ñï+, f n + ‚àë' m : ‚Ñï+, f (-m) :=
  by
  have hpos : HasSum (fun n : ‚Ñï => f (n + 1)) (‚àë' n : ‚Ñï+, f n) :=
    by
    rw [‚Üê_root_.Equiv.pnatEquivNat.hasSum_iff]
    simp_rw [Equiv.pnatEquivNat] at *
    simp at *
    have hf3 : Summable ((fun n : ‚Ñï => f (‚Üën + 1)) ‚àò PNat.natPred) :=
      by
      have hs : Summable fun n : ‚Ñï+ => f n := by apply (int_nat_sum f hf2).subtype
      apply Summable.congr hs
      intro b; simp; congr; simp
    rw [Summable.hasSum_iff hf3]
    congr
    funext
    simp
    congr
    norm_cast
    simp
  have hneg : HasSum (fun n : ‚Ñï => f (-n.succ)) (‚àë' n : ‚Ñï+, f (-n)) :=
    by
    rw [‚Üê_root_.Equiv.pnatEquivNat.hasSum_iff]
    simp_rw [Equiv.pnatEquivNat] at *
    rw [Summable.hasSum_iff _]
    congr
    funext
    simp
    congr
    simp_rw [PNat.natPred]
    simp
    ring
    rw [Equiv.summable_iff]
    have H : Summable fun d : ‚Ñ§ => f d.pred :=
      by
      have := succEquiv.symm.summable_iff.2 hf2
      apply this
    have H2 := summable_neg _ H
    have := int_nat_sum _ H2
    apply Summable.congr this
    intro b
    simp
    congr
    simp_rw [Int.pred]
    ring
  have := (HasSum.pos_add_zero_add_neg hpos hneg).tsum_eq
  rw [this]
  ring_nf

/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (K ¬´expr ‚äÜ ¬ª s) -/
theorem hasDerivAt_tsum_fun {Œ± : Type _} (f : Œ± ‚Üí ‚ÑÇ ‚Üí ‚ÑÇ)
    {s : Set ‚ÑÇ} (hs : IsOpen s) (x : ‚ÑÇ) (hx : x ‚àà s)
    (hf : ‚àÄ y : ‚ÑÇ, y ‚àà s ‚Üí Summable fun n : Œ± => f n y)
    (hu :‚àÄ (K) (_ : K ‚äÜ s), IsCompact K ‚Üí
          ‚àÉ u : Œ± ‚Üí ‚Ñù, Summable u ‚àß ‚àÄ (n : Œ±) (k : K), Complex.abs (deriv (f n) k) ‚â§ u n)
    (hf2 : ‚àÄ (n : Œ±) (r : s), DifferentiableAt ‚ÑÇ (f n) r) :
    HasDerivAt (fun z => ‚àë' n : Œ±, f n z) (‚àë' n : Œ±, deriv (fun z => f n z) x) x :=
  by
  have A :
    ‚àÄ x : ‚ÑÇ,
      x ‚àà s ‚Üí
        Tendsto (fun t : Finset Œ± => ‚àë n in t, (fun z => f n z) x) atTop
          (ùìù (‚àë' n : Œ±, (fun z => f n z) x)) :=
    by
    intro y hy
    apply Summable.hasSum
    simp
    apply hf y hy

  apply hasDerivAt_of_tendstoLocallyUniformlyOn hs _ _ A hx
  use fun n : Finset Œ± => fun a => ‚àë i in n, deriv (fun z => f i z) a
  rw [tendstoLocallyUniformlyOn_iff_forall_isCompact hs]
  intro K hK1 hK2
  have HU := hu K hK1 hK2
  obtain ‚ü®u, hu1, hu2‚ü© := HU
  apply tendstoUniformlyOn_tsum hu1
  intro n x hx
  simp
  apply hu2 n ‚ü®x, hx‚ü©
  apply eventually_of_forall
  intro t r hr
  apply HasDerivAt.sum
  intro q _
  rw [hasDerivAt_deriv_iff]
  simp
  apply hf2 q ‚ü®r, hr‚ü©

/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (K ¬´expr ‚äÜ ¬ª s) -/
theorem hasDerivWithinAt_tsum_fun {Œ± : Type _} (f : Œ± ‚Üí ‚ÑÇ ‚Üí ‚ÑÇ)
    {s : Set ‚ÑÇ} (hs : IsOpen s) (x : ‚ÑÇ) (hx : x ‚àà s)
    (hf : ‚àÄ y : ‚ÑÇ, y ‚àà s ‚Üí Summable fun n : Œ± => f n y)
    (hu :
      ‚àÄ (K) (_ : K ‚äÜ s),
        IsCompact K ‚Üí
          ‚àÉ u : Œ± ‚Üí ‚Ñù, Summable u ‚àß ‚àÄ (n : Œ±) (k : K), Complex.abs (deriv (f n) k) ‚â§ u n)
    (hf2 : ‚àÄ (n : Œ±) (r : s), DifferentiableAt ‚ÑÇ (f n) r) :
    HasDerivWithinAt (fun z => ‚àë' n : Œ±, f n z) (‚àë' n : Œ±, deriv (fun z => f n z) x) s x := by
  apply (hasDerivAt_tsum_fun f hs x hx hf hu hf2).hasDerivWithinAt

/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (K ¬´expr ‚äÜ ¬ª s) -/
theorem hasDerivWithinAt_tsum_fun' {Œ± : Type _} (f : Œ± ‚Üí ‚ÑÇ ‚Üí ‚ÑÇ)
    {s : Set ‚ÑÇ} (hs : IsOpen s) (x : ‚ÑÇ) (hx : x ‚àà s)
    (hf : ‚àÄ y : ‚ÑÇ, y ‚àà s ‚Üí Summable fun n : Œ± => f n y)
    (hu :
      ‚àÄ (K) (_ : K ‚äÜ s),
        IsCompact K ‚Üí
          ‚àÉ u : Œ± ‚Üí ‚Ñù, Summable u ‚àß ‚àÄ (n : Œ±) (k : K), Complex.abs (deriv (f n) k) ‚â§ u n)
    (hf2 : ‚àÄ (n : Œ±) (r : s), DifferentiableAt ‚ÑÇ (f n) r) :
    HasDerivWithinAt (fun z => ‚àë' n : Œ±, f n z) (‚àë' n : Œ±, derivWithin (fun z => f n z) s x) s x :=
  by
  have := hasDerivWithinAt_tsum_fun f hs x hx hf hu hf2
  have Hd : (‚àë' (n : Œ±), deriv (fun z => f n z) x) = (‚àë' n : Œ±, derivWithin (fun z => f n z) s x) :=
    by
    apply tsum_congr
    intro n
    apply symm
    apply DifferentiableAt.derivWithin
    apply hf2 n ‚ü®x, hx‚ü©
    apply IsOpen.uniqueDiffWithinAt hs hx
  rw [Hd] at this
  convert this

/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (K ¬´expr ‚äÜ ¬ª s) -/
theorem deriv_tsum_fun' {Œ± : Type _} (f : Œ± ‚Üí ‚ÑÇ ‚Üí ‚ÑÇ) {s : Set ‚ÑÇ}
    (hs : IsOpen s) (x : ‚ÑÇ) (hx : x ‚àà s) (hf : ‚àÄ y : ‚ÑÇ, y ‚àà s ‚Üí Summable fun n : Œ± => f n y)
    (hu :
      ‚àÄ (K) (_ : K ‚äÜ s),
        IsCompact K ‚Üí
          ‚àÉ u : Œ± ‚Üí ‚Ñù, Summable u ‚àß ‚àÄ (n : Œ±) (k : K), Complex.abs (deriv (f n) k) ‚â§ u n)
    (hf2 : ‚àÄ (n : Œ±) (r : s), DifferentiableAt ‚ÑÇ (f n) r) :
    derivWithin (fun z => ‚àë' n : Œ±, f n z) s x = ‚àë' n : Œ±, derivWithin (fun z => f n z) s x := by
  apply
    HasDerivWithinAt.derivWithin (hasDerivWithinAt_tsum_fun' f hs x hx hf hu hf2)
      (IsOpen.uniqueDiffWithinAt hs hx)
